<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title><![CDATA[Marko Živanović]]></title>
    <link>http://marko.zivanovic.in.rs/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <description></description>
    <pubDate>Wed, 25 Nov 2015 10:29:17 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title><![CDATA[Semantic version parser in C++]]></title>
      <link>http://marko.zivanovic.in.rs/2015/11/25/semver_parser_cpp/</link>
      <guid>http://marko.zivanovic.in.rs/2015/11/25/semver_parser_cpp/</guid>
      <pubDate>Wed, 25 Nov 2015 10:29:17 GMT</pubDate>
      <description>
      <![CDATA[C++14 library for parsing and comparing semantic versioning 2.0.0 version strings.]]>
      
      </description>
      <content:encoded><![CDATA[<h1 id="TL;DR">TL;DR</h1><ul> <li>C++14 library for parsing and comparing semantic versioning 2.0.0 (semver200) version strings;</li> <li>Git repo: <a href="https://github.com/zmarko/semver" target="_blank" rel="external">https://github.com/zmarko/semver</a>;</li> <li>Used in production;</li> <li>MIT license;</li> <li>Flexible design.</li> </ul> <h1 id="Introduction">Introduction</h1><p>One of the projects I’m working on (a security monitoring agent) consists of two principal components: an <em>engine</em> that does the actual work and the <em>service</em> that handles startup, shutdown, updates, etc. The service component is expected to be stable and only infrequently updated, while the engine undergoes continuous development and deployment of new versions. As with all such loosely coupled systems, I need a way for different components to know if they can “talk” to each other, i.e. if the public interface between them is not changed.</p> <p>This is exactly the situation <a href="http://semver.org/" target="_blank" rel="external">semantic versioning</a> specification is designed to help address.</p> <p>Not wanting to re-invent the wheel, I start searching Google, GitHub, etc. for C++ (the language the software is being written in) library that can parse and compare semantic version strings. Requirements are really simple:</p> <ul> <li>correct implementation of semantic versioning 2.0.0 specification;</li> <li>no external dependencies.</li> </ul> <p>Even though the search came up with a few candidates, none of them fit these requirements, so, off I went rolling my own.</p> <p>The results of the effort can be accessed here: <a href="https://github.com/zmarko/semver" target="_blank" rel="external">https://github.com/zmarko/semver</a>.<br>The code is written in C++14, uses only STL and is released under business-friendly MIT license. It consists of a handful of header and source files and comes with <a href="https://cmake.org/" target="_blank" rel="external">CMake</a> project files that build the library and run a bunch of unit tests.</p> <h1 id="Usage">Usage</h1><p>All the complexities of string parsing and version comparison according to semver200 specification are hidden behind, hopefully, easy-to-use facade. Comparing version strings should be as easy as:</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"semver200.h"</span></span></span><br><span class="line">...</span><br><span class="line">version::<span class="function">Semver200_version <span class="title">v1</span><span class="params">(<span class="string">"1.0.0"</span>)</span></span>;</span><br><span class="line">version::<span class="function">Semver200_version <span class="title">v2</span><span class="params">(<span class="string">"2.0.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (v2 &gt; v1) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v2 &lt;&lt; <span class="string">" is indeed greater than "</span> &lt;&lt; v1 &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"This thing is broken, what a waste of time!"</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>It is also possible to access individual version fields:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"semver200.h"</span></span></span><br><span class="line">...</span><br><span class="line">version::<span class="function">Semver200_version <span class="title">v</span><span class="params">(<span class="string">"1.2.3-alpha.1+build.no.123"</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Major: "</span> &lt;&lt; v.major() &lt;&lt; <span class="built_in">std</span>::endl; <span class="comment">// int 1</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Minor: "</span> &lt;&lt; v.minor() &lt;&lt; <span class="built_in">std</span>::endl; <span class="comment">// int 2</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Patch: "</span> &lt;&lt; v.patch() &lt;&lt; <span class="built_in">std</span>::endl; <span class="comment">// int 3</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Pre-release: "</span> &lt;&lt; v.prerelease() &lt;&lt; <span class="built_in">std</span>::endl; <span class="comment">// string alpha.1</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Build: "</span> &lt;&lt; v.build() &lt;&lt; <span class="built_in">std</span>::endl; <span class="comment">// string build.no.123</span></span><br></pre></td></tr></table></figure></p> <h1 id="Advanced_usage">Advanced usage</h1><p>Under the hood, the library builds on two major abstractions: <strong>parser</strong> and <strong>comparator</strong>. As you can, probably, guess by the names, parser, well, parses strings into <code>Version_data</code> structure and comparator performs comparison of two instances of this structure.</p> <p>The library comes with semantic versioning 2.0.0 compatible implementations of these interfaces, but, you can write your own parser, comparator or both.</p> <p>You can check <code>semver200.h</code> header file for signatures and <code>Semver200_comparator.cpp</code> and <code>Semver200_parser.cpp</code> for implementations.</p> <h1 id="Conclusion">Conclusion</h1><p>I’d love to hear from you whether you are using this code or you have any comment, issue, bug report or anything else to say on this subject. You can use either comment here or file an <a href="https://github.com/zmarko/semver/issues" target="_blank" rel="external">issue</a>.</p>]]></content:encoded>
      <comments>http://marko.zivanovic.in.rs/2015/11/25/semver_parser_cpp/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
