<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title><![CDATA[Marko Živanović]]></title>
    <link>http://marko.zivanovic.in.rs/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <description></description>
    <pubDate>Wed, 25 Nov 2015 13:31:27 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title><![CDATA[Semantic version parser in C++]]></title>
      <link>http://marko.zivanovic.in.rs/2015/11/25/semver_parser_cpp/</link>
      <guid>http://marko.zivanovic.in.rs/2015/11/25/semver_parser_cpp/</guid>
      <pubDate>Wed, 25 Nov 2015 13:31:27 GMT</pubDate>
      <description>
      <![CDATA[C++14 library for parsing and comparing semantic versioning 2.0.0 version strings.]]>
      
      </description>
      <content:encoded><![CDATA[<h1 id="TL;DR">TL;DR</h1><ul> <li>C++14 library for parsing and comparing semantic versioning 2.0.0 (semver200) version strings;</li> <li>Git repo: <a href="https://github.com/zmarko/semver" target="_blank" rel="external">https://github.com/zmarko/semver</a>;</li> <li>Used in production;</li> <li>MIT license;</li> <li>Flexible design.</li> </ul> <h1 id="Introduction">Introduction</h1><p>One of the projects I’m working on (a security monitoring agent) consists of two principal components: an <em>engine</em> that does the actual work and the <em>service</em> that handles startup, shutdown, updates, etc. The service component is expected to be stable and only infrequently updated, while the engine undergoes continuous development and deployment of new versions. As with all such loosely coupled systems, I need a way for different components to know if they can “talk” to each other, i.e. if the public interface between them is not changed.</p> <p>This is exactly the situation <a href="http://semver.org/" target="_blank" rel="external">semantic versioning</a> specification is designed to help address.</p> <p>Not wanting to re-invent the wheel, I start searching Google, GitHub, etc. for C++ (the language the software is being written in) library that can parse and compare semantic version strings. Requirements are really simple:</p> <ul> <li>correct implementation of semantic versioning 2.0.0 specification;</li> <li>no external dependencies.</li> </ul> <p>Even though the search came up with a few candidates, none of them fit these requirements, so, off I went rolling my own.</p> <p>The results of the effort can be accessed here: <a href="https://github.com/zmarko/semver" target="_blank" rel="external">https://github.com/zmarko/semver</a>.<br>The code is written in C++14, uses only STL and is released under business-friendly MIT license. It consists of a handful of header and source files and comes with <a href="https://cmake.org/" target="_blank" rel="external">CMake</a> project files that build the library and run a bunch of unit tests.</p> <h1 id="Usage">Usage</h1><p>All the complexities of string parsing and version comparison according to semver200 specification are hidden behind, hopefully, easy-to-use facade. Comparing version strings should be as easy as:</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"semver200.h"</span></span></span><br><span class="line">...</span><br><span class="line">version::<span class="function">Semver200_version <span class="title">v1</span><span class="params">(<span class="string">"1.0.0"</span>)</span></span>;</span><br><span class="line">version::<span class="function">Semver200_version <span class="title">v2</span><span class="params">(<span class="string">"2.0.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (v2 &gt; v1) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v2 &lt;&lt; <span class="string">" is indeed greater than "</span> &lt;&lt; v1 &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"This thing is broken, what a waste of time!"</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>It is also possible to access individual version fields:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"semver200.h"</span></span></span><br><span class="line">...</span><br><span class="line">version::<span class="function">Semver200_version <span class="title">v</span><span class="params">(<span class="string">"1.2.3-alpha.1+build.no.123"</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Major: "</span> &lt;&lt; v.major() &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Minor: "</span> &lt;&lt; v.minor() &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Patch: "</span> &lt;&lt; v.patch() &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Pre-release: "</span> &lt;&lt; v.prerelease() &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Build: "</span> &lt;&lt; v.build() &lt;&lt; <span class="built_in">std</span>::endl;</span><br></pre></td></tr></table></figure></p> <p>and the output should be:<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Major</span>: <span class="string">1</span></span><br><span class="line"><span class="attribute">Minor</span>: <span class="string">2</span></span><br><span class="line"><span class="attribute">Patch</span>: <span class="string">3</span></span><br><span class="line"><span class="attribute">Pre-release</span>: <span class="string">alpha.1</span></span><br><span class="line"><span class="attribute">Build</span>: <span class="string">build.no.123</span></span><br></pre></td></tr></table></figure></p> <h1 id="Building">Building</h1><p>Library is developed and tested on Visual Studio 2015, but, any C++14-compatible compiler should work, as well.</p> <p>Library itself does not have any external dependencies. Unit tests that verify the library work as expected, on the other hand, depend on the <a href="http://www.boost.org/doc/libs/1_59_0/libs/test/doc/html/index.html" target="_blank" rel="external">Boost.Test</a> library. If you do not have and do not want to install Boost.Test, then comment out appropriate section of CMakeLists.txt file.</p> <p>The project comes with CMake project files. In order to build semver library you should:</p> <ul> <li>create, if it doesn’t already exist, directory <code>build</code> in the project directory;</li> <li>invoke <code>cmake ..</code> in <code>build</code> directory;</li> <li>once CMake is done, use your toolset (Visual Studio, nmake, make, …) to build the library;</li> <li>remember to link in the library you have built and to include <code>./include</code> directory to your build.</li> </ul> <h1 id="Advanced_usage">Advanced usage</h1><p>Under the hood, the library builds on two major abstractions: <strong>parser</strong> and <strong>comparator</strong>. As you can, probably, guess by the names, parser, well, parses strings into <code>Version_data</code> structure and comparator performs comparison of two instances of this structure.</p> <p>The library comes with semantic versioning 2.0.0 compatible implementations of these interfaces, but, you can write your own parser, comparator or both.</p> <p>You can check <code>semver200.h</code> header file for signatures and <code>Semver200_comparator.cpp</code> and <code>Semver200_parser.cpp</code> for implementations.</p> <h1 id="Conclusion">Conclusion</h1><p>I’d love to hear from you whether you are using this code or you have any comment, issue, bug report or anything else to say on this subject. You can use either comment here or file an <a href="https://github.com/zmarko/semver/issues" target="_blank" rel="external">issue</a>.</p>]]></content:encoded>
      <comments>http://marko.zivanovic.in.rs/2015/11/25/semver_parser_cpp/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
