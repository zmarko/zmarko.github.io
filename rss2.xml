<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title><![CDATA[Marko Zivanovic]]></title>
    <link>http://marko.zivanovic.in.rs/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <description></description>
    <pubDate>Thu, 10 Dec 2015 14:01:11 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title><![CDATA[Syslog Bulk Uploader Tool]]></title>
      <link>http://marko.zivanovic.in.rs/2015/12/10/syslog-bulk-uploader/</link>
      <guid>http://marko.zivanovic.in.rs/2015/12/10/syslog-bulk-uploader/</guid>
      <pubDate>Thu, 10 Dec 2015 14:01:44 GMT</pubDate>
      <description>
      <![CDATA[Command line tool for sending logs from text files to syslog server.]]>
      
      </description>
      <content:encoded><![CDATA[<h1 id="Introduction">Introduction</h1><p>One of the <a href="http://ast.co.rs/aspen.html" target="_blank" rel="external">flagship products</a> I’m working on is a <a href="https://en.wikipedia.org/wiki/Security_information_and_event_management" target="_blank" rel="external">SIEM</a>-type software. It’s principal input are logs generated by network hardware, operating systems, applications, etc. Testing such a system often times consists of feeding it various selection of logs and checking generated outputs (databases, notifications, etc.) for expected values.</p> <p>Inspired by internal utilities we’re using for this purpose, I’ve written an open source utility for doing the same thing - sending a bunch of logs in text files to syslog server.</p> <p>Utility is available at <a href="https://github.com/zmarko/syslog-bulk-uploader" target="_blank" rel="external">https://github.com/zmarko/syslog-bulk-uploader</a>; it is written in C++ and released under MIT license.</p> <h1 id="Usage">Usage</h1><h2 id="Input">Input</h2><p>Input files need to be in the following format: <code>&lt;timestamp&gt; &lt;facility.severity&gt; &lt;source&gt; &lt;message&gt;</code>. Individual fields are defined as:</p> <dl><dt>timestamp</dt><dd>in format YYYY-MM-DD HH:MM:SS</dd><br><dt>facility</dt><dd>one of syslog facility strings: <code>kern, user, mail, daemon, auth, syslog, lpr, news, uucp, clock, authpriv, ftp, ntp, logaudit, logalert, cron, local0, local1, local2, local3, local4, local5, local6, local7</code></dd><br><dt>severity</dt><dd>one of syslog severity strings: <code>emergency, alert, critical, error, warning, notice, informational, debug</code></dd><br><dt>source</dt><dd>IP address or host name of message source</dd><br><dt>message</dt><dd>the text of the message itself</dd></dl> <h2 id="Command_line">Command line</h2><p>The program is invoked as <code>syslog-bulk-uploader [option]... [file]...</code>, with the following options:</p> <dl><dt>-h –help</dt><dd>display help message, then exit</dd><br><dt>-v –version</dt><dd>display version information, then exit</dd><br><dt>-m –mps num</dt><dd>send messages at specified rate per second; default, if not specified, is 1000</dd><br><dt>-d –dest dest</dt><dd>destination host name</dd><br><dt>-p –port arg</dt><dd>destination port; default, if not specified, is 514</dd><br><dt>[-f –files] filename</dt><dd>one or more input files; option name (-f or –file) is optional, i.e. all non-named arguments will be interpreted as filenames</dd></dl> <h1 id="Building">Building</h1><p>Detailed information on building the utility from source is available on <a href="https://github.com/zmarko/syslog-bulk-uploader#building-from-source" target="_blank" rel="external">GitHub project page</a>.</p> <h1 id="Conclusion">Conclusion</h1><p>If you find this utility useful, have an issue to report or anything else to say on the subject feel free to comment here or file an issue <a href="https://github.com/zmarko/syslog-bulk-uploader/issues" target="_blank" rel="external">here</a>.</p>]]></content:encoded>
      <comments>http://marko.zivanovic.in.rs/2015/12/10/syslog-bulk-uploader/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Semantic version parser in C++]]></title>
      <link>http://marko.zivanovic.in.rs/2015/11/25/semver_parser_cpp/</link>
      <guid>http://marko.zivanovic.in.rs/2015/11/25/semver_parser_cpp/</guid>
      <pubDate>Wed, 25 Nov 2015 14:36:24 GMT</pubDate>
      <description>
      <![CDATA[C++14 library for parsing and comparing semantic versioning 2.0.0 version strings.]]>
      
      </description>
      <content:encoded><![CDATA[<h1 id="TL;DR">TL;DR</h1><ul> <li>C++14 library for parsing and comparing semantic versioning 2.0.0 (semver200) version strings;</li> <li>Git repo: <a href="https://github.com/zmarko/semver" target="_blank" rel="external">https://github.com/zmarko/semver</a>;</li> <li>Used in production; thoroughly unit tested;</li> <li>MIT license;</li> <li>Flexible design.</li> </ul> <h1 id="Introduction">Introduction</h1><p>One of the projects I’m working on (a security monitoring agent) consists of two principal components: an <em>engine</em> that does the actual work and the <em>service</em> that handles startup, shutdown, updates, etc. The service component is expected to be stable and only infrequently updated, while the engine undergoes continuous development and deployment of new versions. As with all such loosely coupled systems, I need a way for different components to know if they can “talk” to each other, i.e. if the public interface between them is not changed.</p> <p>This is exactly the situation <a href="http://semver.org/" target="_blank" rel="external">semantic versioning</a> specification is designed to help address.</p> <p>Not wanting to re-invent the wheel, I start searching Google, GitHub, etc. for C++ (the language the software is being written in) library that can parse and compare semantic version strings. Requirements are really simple:</p> <ul> <li>correct implementation of semantic versioning 2.0.0 specification;</li> <li>no external dependencies.</li> </ul> <p>Even though the search came up with a few candidates, none of them fit these requirements, so, off I went rolling my own.</p> <p>The results of the effort can be accessed here: <a href="https://github.com/zmarko/semver" target="_blank" rel="external">https://github.com/zmarko/semver</a>.<br>The code is written in C++14, uses only STL and is released under business-friendly MIT license. It consists of a handful of header and source files and comes with <a href="https://cmake.org/" target="_blank" rel="external">CMake</a> project files that build the library and run a bunch of unit tests.</p> <h1 id="Usage">Usage</h1><p>All the complexities of string parsing and version comparison according to semver200 specification are hidden behind, hopefully, easy-to-use facade. Comparing version strings should be as easy as:</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"semver200.h"</span></span></span><br><span class="line">...</span><br><span class="line">version::<span class="function">Semver200_version <span class="title">v1</span><span class="params">(<span class="string">"1.0.0"</span>)</span></span>;</span><br><span class="line">version::<span class="function">Semver200_version <span class="title">v2</span><span class="params">(<span class="string">"2.0.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (v2 &gt; v1) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v2 &lt;&lt; <span class="string">" is indeed greater than "</span> &lt;&lt; v1 &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"This thing is broken, what a waste of time!"</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>It is also possible to access individual version fields:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"semver200.h"</span></span></span><br><span class="line">...</span><br><span class="line">version::<span class="function">Semver200_version <span class="title">v</span><span class="params">(<span class="string">"1.2.3-alpha.1+build.no.123"</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Major: "</span> &lt;&lt; v.major() &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Minor: "</span> &lt;&lt; v.minor() &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Patch: "</span> &lt;&lt; v.patch() &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Pre-release: "</span> &lt;&lt; v.prerelease() &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Build: "</span> &lt;&lt; v.build() &lt;&lt; <span class="built_in">std</span>::endl;</span><br></pre></td></tr></table></figure></p> <p>and the output should be:<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Major</span>: <span class="string">1</span></span><br><span class="line"><span class="attribute">Minor</span>: <span class="string">2</span></span><br><span class="line"><span class="attribute">Patch</span>: <span class="string">3</span></span><br><span class="line"><span class="attribute">Pre-release</span>: <span class="string">alpha.1</span></span><br><span class="line"><span class="attribute">Build</span>: <span class="string">build.no.123</span></span><br></pre></td></tr></table></figure></p> <h1 id="Building">Building</h1><p>The code should build with any C++14-compatible compiler. I have tested it on following platforms:</p> <ul> <li>Microsoft Visual Studio 2015</li> <li>GCC 5.1.1</li> <li>Clang 3.7.0</li> </ul> <p>Library itself does not have any external dependencies. Unit tests that verify the library work as expected, on the other hand, depend on the <a href="http://www.boost.org/doc/libs/1_59_0/libs/test/doc/html/index.html" target="_blank" rel="external">Boost.Test</a> library. If you do not have and do not want to install Boost.Test, then comment out appropriate section of CMakeLists.txt file.</p> <p>The project comes with CMake project files. In order to build semver library you should:</p> <ul> <li>create, if it doesn’t already exist, directory <code>build</code> in the project directory;</li> <li>invoke <code>cmake ..</code> in <code>build</code> directory;</li> <li>once CMake is done, use your toolset (Visual Studio, nmake, make, …) to build the library;</li> <li>remember to link in the library you have built and to include <code>./include</code> directory to your build.</li> </ul> <h1 id="Advanced_usage">Advanced usage</h1><p>Under the hood, the library builds on two major abstractions: <strong>parser</strong> and <strong>comparator</strong>. As you can, probably, guess by the names, parser, well, parses strings into <code>Version_data</code> structure and comparator performs comparison of two instances of this structure.</p> <p>The library comes with semantic versioning 2.0.0 compatible implementations of these interfaces, but, you can write your own parser, comparator or both.</p> <p>You can check <code>semver200.h</code> header file for signatures and <code>Semver200_comparator.cpp</code> and <code>Semver200_parser.cpp</code> for implementations.</p> <h1 id="Conclusion">Conclusion</h1><p>I’d love to hear from you whether you are using this code or you have any comment, issue, bug report or anything else to say on this subject. You can use either comment here or file an <a href="https://github.com/zmarko/semver/issues" target="_blank" rel="external">issue</a>.</p>]]></content:encoded>
      <comments>http://marko.zivanovic.in.rs/2015/11/25/semver_parser_cpp/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
